<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>·ä†·à∞·çã ·ã≤·åÇ·â≥·àç ·â¢·äï·åé ·å®·ãã·â≥</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Ethiopic:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* [ALL CSS STYLES FROM YOUR ORIGINAL FILE - Keep all CSS exactly as is] */
        /* MOBILE FIRST DESIGN - OPTIMIZED */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Times New Roman', 'Noto Sans Ethiopic', sans-serif;
            background: linear-gradient(135deg, #0d47a1 0%, #1a237e 100%);
            color: white;
            touch-action: manipulation;
        }

        .amharic-text {
            font-family: 'Noto Sans Ethiopic', 'Times New Roman', sans-serif;
        }

        /* [Keep ALL your CSS styles - they remain exactly the same] */
        /* ... All your existing CSS ... */
        
        /* [Rest of your CSS remains unchanged] */
    </style>
</head>
<body>
    <!-- [ALL YOUR HTML ELEMENTS REMAIN EXACTLY THE SAME] -->
    <!-- Audio Elements -->
    <audio id="callAudio" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-bell-notification-933.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="winAudio" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>

    <!-- [Keep ALL your HTML structure exactly as is - from Connection Status to Admin Panel] -->
    <!-- ... All your HTML elements ... -->
    
    <!-- [Your complete HTML structure remains here] -->

    <script>
        // Deno Server Backend - Embedded in Frontend
        // This code runs on Deno Deploy when deployed as a server
        if (typeof Deno !== 'undefined') {
            // We're running in Deno environment (server-side)
            console.log("Starting Deno WebSocket server...");
            
            // Deno Server Code
            interface Player {
                id: string;
                name: string;
                phone: string;
                stake: number;
                boardId: number;
                gameType: string;
                balance: number;
                paid: boolean;
                socket?: WebSocket;
                markedNumbers: Set<number>;
                boardNumbers: number[];
                winAmount?: number;
            }

            interface GameState {
                players: Player[];
                calledNumbers: number[];
                gameActive: boolean;
                currentNumber: number | null;
                adminConnected: boolean;
                winningPatterns: Map<string, string[]>;
                lastWinner: string | null;
            }

            const gameState: GameState = {
                players: [],
                calledNumbers: [],
                gameActive: false,
                currentNumber: null,
                adminConnected: false,
                winningPatterns: new Map([
                    ['75ball', ['row', 'column', 'diagonal', 'four-corners', 'full-house']],
                    ['90ball', ['one-line', 'two-lines', 'full-house']],
                    ['30ball', ['full-house']],
                    ['50ball', ['row', 'column', 'diagonal', 'four-corners', 'full-house']],
                    ['pattern', ['x-pattern', 'frame', 'postage-stamp', 'small-diamond']],
                    ['coverall', ['full-board']]
                ]),
                lastWinner: null
            };

            // Helper Functions for Server
            function generatePlayerId(): string {
                return 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            function generateBoardNumbers(gameType: string): number[] {
                let numbers: number[] = [];
                const ranges = {
                    '75ball': { min: 1, max: 75, count: 24 },
                    '90ball': { min: 1, max: 90, count: 15 },
                    '30ball': { min: 1, max: 30, count: 9 },
                    '50ball': { min: 1, max: 50, count: 24 },
                    'pattern': { min: 1, max: 75, count: 24 },
                    'coverall': { min: 1, max: 90, count: 45 }
                };

                const range = ranges[gameType as keyof typeof ranges] || ranges['75ball'];
                const allNumbers = Array.from({ length: range.max - range.min + 1 }, (_, i) => i + range.min);
                
                // Shuffle and take required count
                for (let i = allNumbers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allNumbers[i], allNumbers[j]] = [allNumbers[j], allNumbers[i]];
                }
                
                return allNumbers.slice(0, range.count).sort((a, b) => a - b);
            }

            function calculateWinAmount(stake: number): number {
                const totalPot = 90 * stake * 0.8; // 90 players, 80% payout
                const serviceFee = totalPot * 0.03; // 3% service fee
                return Math.floor(totalPot - serviceFee);
            }

            function broadcastToAll(message: any, excludePlayerId: string = '') {
                const messageStr = JSON.stringify(message);
                gameState.players.forEach(player => {
                    if (player.id !== excludePlayerId && player.socket && player.socket.readyState === WebSocket.OPEN) {
                        try {
                            player.socket.send(messageStr);
                        } catch (error) {
                            console.error(`Error broadcasting to player ${player.id}:`, error);
                        }
                    }
                });
            }

            function broadcastGameState() {
                const state = {
                    calledNumbers: gameState.calledNumbers,
                    gameActive: gameState.gameActive,
                    players: gameState.players.map(p => ({
                        id: p.id,
                        name: p.name,
                        phone: p.phone,
                        stake: p.stake,
                        balance: p.balance,
                        paid: p.paid,
                        gameType: p.gameType
                    })),
                    currentNumber: gameState.currentNumber,
                    totalPlayers: gameState.players.length
                };
                
                broadcastToAll({
                    type: 'game_state',
                    state: state
                });
            }

            function callNextNumber(): number {
                if (gameState.calledNumbers.length >= 90) return 0;
                
                let nextNumber: number;
                do {
                    nextNumber = Math.floor(Math.random() * 90) + 1;
                } while (gameState.calledNumbers.includes(nextNumber) && gameState.calledNumbers.length < 90);
                
                gameState.calledNumbers.push(nextNumber);
                gameState.currentNumber = nextNumber;
                
                // Broadcast to all players
                broadcastToAll({
                    type: 'number_called',
                    number: nextNumber,
                    display: nextNumber,
                    calledCount: gameState.calledNumbers.length,
                    totalPlayers: gameState.players.length
                });
                
                console.log(`Called number: ${nextNumber}, Total called: ${gameState.calledNumbers.length}`);
                return nextNumber;
            }

            // WebSocket Message Handler
            function handleMessage(data: any, ws: WebSocket, playerId: string = '') {
                console.log('Server received:', data.type, 'from', playerId || 'unknown');
                
                switch (data.type) {
                    case 'admin_login':
                        handleAdminLogin(data, ws);
                        break;
                        
                    case 'register':
                        handleRegistration(data, ws);
                        break;
                        
                    case 'claim_win':
                        handleWinClaim(data, ws);
                        break;
                        
                    case 'admin_command':
                        handleAdminCommand(data, ws);
                        break;
                        
                    case 'mark_number':
                        handleMarkNumber(data, ws);
                        break;
                        
                    case 'get_state':
                        sendGameState(ws, playerId);
                        break;
                        
                    case 'heartbeat':
                        // Just acknowledge to keep connection alive
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'heartbeat_ack' }));
                        }
                        break;
                        
                    default:
                        ws.send(JSON.stringify({
                            type: 'error',
                            message: 'Unknown message type'
                        }));
                }
            }

            function handleAdminLogin(data: any, ws: WebSocket) {
                if (data.password === 'asse2123') {
                    const adminPlayer: Player = {
                        id: 'admin',
                        name: 'Administrator',
                        phone: '0000000000',
                        stake: 0,
                        boardId: 0,
                        gameType: 'admin',
                        balance: 0,
                        paid: true,
                        socket: ws,
                        markedNumbers: new Set(),
                        boardNumbers: []
                    };
                    
                    gameState.players.push(adminPlayer);
                    gameState.adminConnected = true;
                    
                    ws.send(JSON.stringify({
                        type: 'admin_login_success',
                        message: 'Admin login successful',
                        gameState: {
                            calledNumbers: gameState.calledNumbers,
                            gameActive: gameState.gameActive,
                            players: gameState.players.length - 1, // Exclude admin
                            adminConnected: true
                        }
                    }));
                    
                    console.log('Admin logged in successfully');
                    broadcastGameState();
                } else {
                    ws.send(JSON.stringify({
                        type: 'admin_login_failed',
                        message: 'Invalid admin password'
                    }));
                }
            }

            function handleRegistration(data: any, ws: WebSocket) {
                const { playerName, playerPhone, stake, boardId, gameType } = data;
                
                // Check if player already exists
                const existingPlayer = gameState.players.find(p => p.phone === playerPhone && p.id !== 'admin');
                if (existingPlayer) {
                    // Update existing player's socket
                    existingPlayer.socket = ws;
                    existingPlayer.stake = stake;
                    existingPlayer.boardId = boardId;
                    existingPlayer.gameType = gameType;
                    
                    ws.send(JSON.stringify({
                        type: 'connected',
                        playerId: existingPlayer.id,
                        message: 'Reconnected successfully',
                        boardNumbers: existingPlayer.boardNumbers,
                        markedNumbers: Array.from(existingPlayer.markedNumbers),
                        calledNumbers: gameState.calledNumbers,
                        gameActive: gameState.gameActive
                    }));
                    
                    console.log(`Player ${existingPlayer.name} reconnected`);
                    broadcastGameState();
                    return;
                }
                
                // Create new player
                const playerId = generatePlayerId();
                const boardNumbers = generateBoardNumbers(gameType);
                
                const newPlayer: Player = {
                    id: playerId,
                    name: playerName,
                    phone: playerPhone,
                    stake: stake,
                    boardId: boardId,
                    gameType: gameType,
                    balance: 0,
                    paid: true,
                    socket: ws,
                    markedNumbers: new Set(),
                    boardNumbers: boardNumbers
                };
                
                gameState.players.push(newPlayer);
                
                ws.send(JSON.stringify({
                    type: 'connected',
                    playerId: playerId,
                    message: 'Registration successful',
                    boardNumbers: boardNumbers,
                    calledNumbers: gameState.calledNumbers,
                    gameActive: gameState.gameActive
                }));
                
                console.log(`New player registered: ${playerName} (${playerId})`);
                broadcastGameState();
            }

            function handleWinClaim(data: any, ws: WebSocket) {
                const { playerName, playerId, pattern, amount } = data;
                
                const player = gameState.players.find(p => p.id === playerId);
                if (!player) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Player not found'
                    }));
                    return;
                }
                
                // Check if game is active
                if (!gameState.gameActive) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Game is not active'
                    }));
                    return;
                }
                
                // Check if player has already won
                if (gameState.lastWinner === playerId) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'You have already won this game'
                    }));
                    return;
                }
                
                // Verify win pattern
                const isValidWin = verifyWinPattern(player, pattern);
                
                if (isValidWin) {
                    const winAmount = calculateWinAmount(player.stake);
                    player.balance += winAmount;
                    player.winAmount = winAmount;
                    gameState.lastWinner = playerId;
                    
                    // Broadcast winner announcement
                    broadcastToAll({
                        type: 'winner_announced',
                        winnerName: player.name,
                        winnerId: player.id,
                        pattern: pattern,
                        amount: winAmount,
                        timestamp: Date.now()
                    }, playerId);
                    
                    // Notify winner
                    ws.send(JSON.stringify({
                        type: 'winner_verified',
                        winnerId: player.id,
                        verified: true,
                        amount: winAmount,
                        newBalance: player.balance,
                        message: 'Congratulations! Your win has been verified.'
                    }));
                    
                    console.log(`Winner: ${player.name} won ${winAmount} with pattern ${pattern}`);
                    
                    // Stop game after winner
                    gameState.gameActive = false;
                    broadcastToAll({
                        type: 'game_stopped',
                        message: `Game stopped. ${player.name} won!`,
                        winnerName: player.name,
                        amount: winAmount
                    });
                } else {
                    ws.send(JSON.stringify({
                        type: 'winner_verified',
                        winnerId: player.id,
                        verified: false,
                        message: 'Win claim could not be verified. Please check your pattern.'
                    }));
                }
                
                broadcastGameState();
            }

            function verifyWinPattern(player: Player, pattern: string): boolean {
                // Check if pattern is valid for game type
                const validPatterns = gameState.winningPatterns.get(player.gameType) || [];
                if (!validPatterns.includes(pattern)) {
                    return false;
                }
                
                // Check if player has enough marked numbers
                const markedCount = player.markedNumbers.size;
                const totalNumbers = player.boardNumbers.length;
                
                // Simple verification - in production, implement actual pattern checking
                const patternRequirements: Record<string, number> = {
                    'row': 5,
                    'column': 5,
                    'diagonal': 5,
                    'four-corners': 4,
                    'full-house': totalNumbers,
                    'one-line': 5,
                    'two-lines': 10,
                    'x-pattern': 9,
                    'frame': 16,
                    'postage-stamp': 4,
                    'small-diamond': 5,
                    'full-board': 45
                };
                
                const requiredCount = patternRequirements[pattern] || 5;
                return markedCount >= requiredCount;
            }

            function handleAdminCommand(data: any, ws: WebSocket) {
                const adminPlayer = gameState.players.find(p => p.id === 'admin' && p.socket === ws);
                if (!adminPlayer) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Admin privileges required'
                    }));
                    return;
                }
                
                const { command } = data;
                
                switch (command) {
                    case 'start':
                        gameState.gameActive = true;
                        gameState.calledNumbers = [];
                        gameState.lastWinner = null;
                        broadcastToAll({
                            type: 'game_started',
                            message: 'Game started! Numbers will be called every 7 seconds.',
                            timestamp: Date.now(),
                            adminName: 'Administrator'
                        });
                        
                        // Start auto-calling numbers
                        let callCount = 0;
                        const intervalId = setInterval(() => {
                            if (gameState.gameActive && callCount < 90) {
                                callNextNumber();
                                callCount++;
                            } else {
                                clearInterval(intervalId);
                                if (callCount >= 90) {
                                    gameState.gameActive = false;
                                    broadcastToAll({
                                        type: 'game_stopped',
                                        message: 'All numbers have been called! No winner this round.'
                                    });
                                }
                            }
                        }, 7000);
                        
                        console.log('Game started by admin');
                        break;
                        
                    case 'stop':
                        gameState.gameActive = false;
                        broadcastToAll({
                            type: 'game_stopped',
                            message: 'Game stopped by admin',
                            adminName: 'Administrator'
                        });
                        console.log('Game stopped by admin');
                        break;
                        
                    case 'call':
                        const number = callNextNumber();
                        if (number === 0) {
                            ws.send(JSON.stringify({
                                type: 'info',
                                message: 'All numbers have been called'
                            }));
                        }
                        break;
                        
                    case 'reset':
                        gameState.calledNumbers = [];
                        gameState.gameActive = false;
                        gameState.currentNumber = null;
                        gameState.lastWinner = null;
                        
                        // Reset all players' marked numbers and generate new boards
                        gameState.players.forEach(player => {
                            if (player.id !== 'admin') {
                                player.markedNumbers.clear();
                                player.boardNumbers = generateBoardNumbers(player.gameType);
                                player.winAmount = undefined;
                            }
                        });
                        
                        broadcastToAll({
                            type: 'game_reset',
                            message: 'Game has been reset. New boards generated.',
                            adminName: 'Administrator'
                        });
                        console.log('Game reset by admin');
                        break;
                        
                    case 'clear_players':
                        // Remove all non-admin players
                        gameState.players = gameState.players.filter(p => p.id === 'admin');
                        broadcastGameState();
                        ws.send(JSON.stringify({
                            type: 'info',
                            message: 'All players cleared'
                        }));
                        break;
                        
                    default:
                        ws.send(JSON.stringify({
                            type: 'error',
                            message: 'Unknown admin command'
                        }));
                }
                
                broadcastGameState();
            }

            function handleMarkNumber(data: any, ws: WebSocket) {
                const { playerId, number } = data;
                const player = gameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Player not found'
                    }));
                    return;
                }
                
                // Check if number was called
                if (!gameState.calledNumbers.includes(number)) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Number has not been called yet'
                    }));
                    return;
                }
                
                // Check if number is in player's board
                if (!player.boardNumbers.includes(number)) {
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: 'Number not on your board'
                    }));
                    return;
                }
                
                player.markedNumbers.add(number);
                
                ws.send(JSON.stringify({
                    type: 'number_marked',
                    number: number,
                    markedNumbers: Array.from(player.markedNumbers),
                    totalMarked: player.markedNumbers.size
                }));
                
                console.log(`Player ${player.name} marked number ${number}`);
            }

            function sendGameState(ws: WebSocket, playerId: string) {
                const player = gameState.players.find(p => p.id === playerId);
                ws.send(JSON.stringify({
                    type: 'game_state',
                    state: {
                        calledNumbers: gameState.calledNumbers,
                        gameActive: gameState.gameActive,
                        players: gameState.players.filter(p => p.id !== 'admin').map(p => ({
                            id: p.id,
                            name: p.name,
                            phone: p.phone,
                            stake: p.stake,
                            balance: p.balance,
                            paid: p.paid,
                            gameType: p.gameType,
                            markedCount: p.markedNumbers.size
                        })),
                        currentNumber: gameState.currentNumber,
                        adminConnected: gameState.adminConnected,
                        totalPlayers: gameState.players.length - (gameState.adminConnected ? 1 : 0),
                        lastWinner: gameState.lastWinner
                    }
                }));
            }

            // Clean up disconnected players
            function cleanupPlayers() {
                const now = Date.now();
                gameState.players = gameState.players.filter(player => {
                    if (player.id === 'admin') return true;
                    
                    if (player.socket && player.socket.readyState === WebSocket.OPEN) {
                        return true;
                    }
                    
                    console.log(`Removing disconnected player: ${player.name}`);
                    return false;
                });
                
                broadcastGameState();
            }

            // Start cleanup interval
            setInterval(cleanupPlayers, 30000);

            // HTTP Server with WebSocket Upgrade for Deno
            async function handleRequest(req) {
                const url = new URL(req.url);
                
                if (req.headers.get("upgrade") === "websocket") {
                    // Handle WebSocket connection
                    const { socket, response } = Deno.upgradeWebSocket(req);
                    
                    socket.onopen = () => {
                        console.log("WebSocket connection established");
                    };
                    
                    socket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            handleMessage(data, socket);
                        } catch (error) {
                            console.error("Error handling message:", error);
                            socket.send(JSON.stringify({
                                type: 'error',
                                message: 'Invalid message format'
                            }));
                        }
                    };
                    
                    socket.onclose = () => {
                        console.log("WebSocket connection closed");
                        cleanupPlayers();
                    };
                    
                    socket.onerror = (error) => {
                        console.error("WebSocket error:", error);
                    };
                    
                    return response;
                }
                
                // Serve HTML for HTTP requests
                if (url.pathname === "/") {
                    return new Response(htmlContent, {
                        headers: {
                            "content-type": "text/html; charset=utf-8",
                        },
                    });
                }
                
                // API endpoints
                if (url.pathname === "/api/status") {
                    return new Response(JSON.stringify({
                        status: "online",
                        players: gameState.players.length - (gameState.adminConnected ? 1 : 0),
                        gameActive: gameState.gameActive,
                        calledNumbers: gameState.calledNumbers.length,
                        adminConnected: gameState.adminConnected,
                        serverTime: new Date().toISOString()
                    }), {
                        headers: { "content-type": "application/json" },
                    });
                }
                
                if (url.pathname === "/api/players") {
                    return new Response(JSON.stringify({
                        players: gameState.players.filter(p => p.id !== 'admin').map(p => ({
                            id: p.id,
                            name: p.name,
                            phone: p.phone,
                            stake: p.stake,
                            gameType: p.gameType,
                            balance: p.balance,
                            markedNumbers: Array.from(p.markedNumbers)
                        }))
                    }), {
                        headers: { "content-type": "application/json" },
                    });
                }
                
                // 404 for other routes
                return new Response("Not Found", { status: 404 });
            }

            // Get HTML content from current document
            const htmlContent = `<!DOCTYPE html>${document.documentElement.outerHTML}`;
            
            // Start Deno server
            console.log("Starting Deno server on port 8000...");
            Deno.serve({ port: 8000 }, handleRequest);
            
        } else {
            // Frontend JavaScript - Runs in browser
            console.log("Starting frontend application...");
            
            // WebSocket Configuration - Auto-detect server
            const WS_URL = (() => {
                if (window.location.hostname === 'localhost' || 
                    window.location.hostname === '127.0.0.1') {
                    return 'ws://localhost:8000';
                }
                // When deployed to Deno Deploy, use wss:// protocol on same host
                const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
                return protocol + window.location.host;
            })();

            // Game State - Optimized
            const gameState = {
                gameType: null,
                payment: 0,
                paymentAmount: 25,
                stake: 25,
                totalWon: 0,
                boardId: 1,
                calledNumbers: [],
                markedNumbers: new Set(),
                gameActive: false,
                playerName: '',
                playerPhone: '',
                totalWithdrawn: 0,
                members: [],
                currentNumber: null,
                winningPatterns: {
                    '75ball': ['row', 'column', 'diagonal', 'four-corners', 'full-house'],
                    '90ball': ['one-line', 'two-lines', 'full-house'],
                    '30ball': ['full-house'],
                    '50ball': ['row', 'column', 'diagonal', 'four-corners', 'full-house'],
                    'pattern': ['x-pattern', 'frame', 'postage-stamp', 'small-diamond'],
                    'coverall': ['full-board']
                },
                winConditions: {
                    'row': '·à®·ãµ·çç',
                    'column': '·ä†·àù·ãµ',
                    'diagonal': '·ã≤·ã´·åç·äì·àç',
                    'four-corners': '·ä†·à´·âµ ·àõ·ä•·ãò·äñ·âΩ',
                    'full-house': '·àô·àâ ·â§·âµ',
                    'one-line': '·ä†·äï·ãµ ·à®·ãµ·çç',
                    'two-lines': '·àÅ·àà·âµ ·à®·ãµ·çç',
                    'x-pattern': 'X ·äï·ãµ·çç',
                    'frame': '·ä†·ãç·à´ ·âÄ·àà·â†·âµ',
                    'postage-stamp': '·àõ·àÖ·â∞·àù',
                    'small-diamond': '·ã≤·ã´·àù·äï·ãµ',
                    'full-board': '·àô·àâ ·â¶·à≠·ãµ'
                },
                ws: null,
                playerId: null,
                isAdmin: false,
                adminPassword: 'asse2123',
                connectionAttempts: 0,
                maxConnectionAttempts: 5,
                serverBoardNumbers: null,
                reconnectionTimer: null,
                heartbeatInterval: null
            };

            // Board Types
            const boardTypes = [
                { id: '75ball', name: '75-·â¢·äï·åé', icon: 'üéØ', desc: '5√ó5 ·ä®BINGO', range: 75, columns: 5 },
                { id: '90ball', name: '90-·â¢·äï·åé', icon: 'üá¨üáß', desc: '9√ó3 ·çà·å£·äï', range: 90, columns: 9 },
                { id: '30ball', name: '30-·â¢·äï·åé', icon: '‚ö°', desc: '3√ó3 ·çç·å•·äê·âµ', range: 30, columns: 3 },
                { id: '50ball', name: '50-·â¢·äï·åé', icon: 'üé≤', desc: '5√ó5 ·ä®BINGO', range: 50, columns: 5 },
                { id: 'pattern', name: '·äï·ãµ·çç ·â¢·äï·åé', icon: '‚ú®', desc: '·â∞·å†·âÄ·àù ·äï·ãµ·çç', range: 75, columns: 5 },
                { id: 'coverall', name: '·àô·àâ ·â§·âµ', icon: 'üèÜ', desc: '·àÅ·àâ·äï·àù ·àù·àç·ä≠·âµ ·ã´·ãµ·à≠·åâ', range: 90, columns: 9 }
            ];

            // WebSocket Functions
            function connectWebSocket() {
                try {
                    updateConnectionStatus('connecting', '·ã®·àö·åà·äì·äù...');
                    
                    const ws = new WebSocket(WS_URL);
                    
                    ws.onopen = () => {
                        console.log('WebSocket connected to:', WS_URL);
                        updateConnectionStatus('connected', '·â∞·åà·äì·äù·â∑·àç');
                        gameState.connectionAttempts = 0;
                        
                        // Start heartbeat
                        startHeartbeat();
                        
                        // Check if admin from URL
                        const urlParams = new URLSearchParams(window.location.search);
                        if (urlParams.get('admin') === 'true') {
                            const password = prompt('·ã®·ä†·àµ·â∞·ã≥·ã∞·à≠ ·ã®·ã≠·àà·çç ·âÉ·àç ·ã´·àµ·åà·â°:', '');
                            if (password === gameState.adminPassword) {
                                sendMessage({ type: 'admin_login', password: password });
                            }
                        }
                        
                        // If player was already registered, reconnect
                        if (gameState.playerId) {
                            sendMessage({
                                type: 'register',
                                playerName: gameState.playerName,
                                playerPhone: gameState.playerPhone,
                                stake: gameState.stake,
                                boardId: gameState.boardId,
                                gameType: gameState.gameType
                            });
                        }
                    };
                    
                    ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            handleWebSocketMessage(message);
                        } catch (error) {
                            console.error('Error parsing message:', error);
                        }
                    };
                    
                    ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        updateConnectionStatus('disconnected', '·àò·åà·äì·äõ ·â∞·âã·à≠·åß·àç');
                        
                        // Stop heartbeat
                        stopHeartbeat();
                        
                        // Attempt reconnection
                        if (gameState.connectionAttempts < gameState.maxConnectionAttempts) {
                            gameState.connectionAttempts++;
                            const delay = Math.min(30000, 3000 * gameState.connectionAttempts);
                            
                            gameState.reconnectionTimer = setTimeout(() => {
                                console.log(`Reconnection attempt ${gameState.connectionAttempts}/${gameState.maxConnectionAttempts}`);
                                connectWebSocket();
                            }, delay);
                        }
                    };
                    
                    ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('disconnected', '·àµ·àÖ·â∞·âµ ·â∞·çà·å•·àØ·àç');
                    };
                    
                    gameState.ws = ws;
                } catch (error) {
                    console.error('Failed to connect:', error);
                    updateConnectionStatus('disconnected', '·àò·åà·äì·äõ ·ä†·àç·â∞·à≥·ä´·àù');
                }
            }

            function startHeartbeat() {
                stopHeartbeat();
                gameState.heartbeatInterval = setInterval(() => {
                    if (gameState.ws && gameState.ws.readyState === WebSocket.OPEN) {
                        sendMessage({ type: 'heartbeat' });
                    }
                }, 30000); // Send heartbeat every 30 seconds
            }

            function stopHeartbeat() {
                if (gameState.heartbeatInterval) {
                    clearInterval(gameState.heartbeatInterval);
                    gameState.heartbeatInterval = null;
                }
            }

            function sendMessage(message) {
                if (gameState.ws && gameState.ws.readyState === WebSocket.OPEN) {
                    try {
                        gameState.ws.send(JSON.stringify(message));
                        return true;
                    } catch (error) {
                        console.error('Error sending message:', error);
                        return false;
                    }
                } else {
                    console.warn('WebSocket not connected');
                    updateConnectionStatus('disconnected', '·àò·åà·äì·äõ ·ã®·àà·àù');
                    return false;
                }
            }

            function handleWebSocketMessage(message) {
                console.log('Received message:', message.type);
                
                switch(message.type) {
                    case 'connected':
                        gameState.playerId = message.playerId;
                        gameState.serverBoardNumbers = message.boardNumbers;
                        gameState.markedNumbers = new Set(message.markedNumbers || []);
                        
                        updateConnectionStatus('connected', `·â∞·åà·äì·äù·â∞·ãã·àç (${gameState.playerName})`);
                        
                        // Regenerate board with server numbers if needed
                        if (message.boardNumbers && gameState.gameType) {
                            regenerateBoardWithServerNumbers();
                        }
                        break;
                        
                    case 'game_state':
                        updateGameState(message.state);
                        break;
                        
                    case 'number_called':
                        handleNumberCalled(message.number, message.display);
                        break;
                        
                    case 'game_started':
                        showNotification('·å®·ãã·â≥ ·â∞·åÄ·àù·àØ·àç! ·âÅ·å•·àÆ·âΩ ·ã≠·å†·à´·àâ...', false);
                        gameState.gameActive = true;
                        document.getElementById('announceBtn').disabled = false;
                        break;
                        
                    case 'game_stopped':
                        showNotification(message.message || '·å®·ãã·â≥ ·â∞·ãà·åç·ã∑·àç', false);
                        gameState.gameActive = false;
                        document.getElementById('announceBtn').disabled = true;
                        
                        // If there's a winner, show their name
                        if (message.winnerName) {
                            setTimeout(() => {
                                showNotification(`${message.winnerName} ·ä†·à∏·äï·çà·ãã·àç! ${message.amount} ·â•·à≠`, false);
                            }, 1000);
                        }
                        break;
                        
                    case 'game_reset':
                        showNotification(message.message || '·å®·ãã·â≥ ·ä•·äï·ã∞·åà·äì ·â∞·åÄ·àù·àØ·àç·ç¢ ·ä†·ã≤·àµ ·â¶·à≠·ãµ', false);
                        gameState.markedNumbers.clear();
                        gameState.calledNumbers = [];
                        updateCalledNumbersDisplay();
                        generateGameBoard();
                        document.getElementById('announceBtn').disabled = false;
                        break;
                        
                    case 'winner_announced':
                        // Show winner notification (for all players)
                        if (message.winnerId !== gameState.playerId) {
                            // Another player won
                            document.getElementById('winnerName').textContent = message.winnerName;
                            document.getElementById('winPattern').textContent = gameState.winConditions[message.pattern] || message.pattern;
                            document.getElementById('displayWinAmount').textContent = `${message.amount.toLocaleString()} ·â•·à≠`;
                            document.getElementById('winnerStatus').textContent = '·àå·àã ·â∞·å´·ãã·âΩ ·ä†·à∏·äï·çè·àç';
                            document.getElementById('winnerNotification').style.display = 'block';
                            
                            const audio = document.getElementById('winAudio');
                            audio.currentTime = 0;
                            audio.play().catch(() => {});
                            
                            // Disable announce button
                            document.getElementById('announceBtn').disabled = true;
                        }
                        break;
                        
                    case 'winner_verified':
                        if (message.winnerId === gameState.playerId) {
                            if (message.verified) {
                                document.getElementById('winnerStatus').textContent = '·ä†·à®·åã·åç·åß·àç ‚úì';
                                document.getElementById('continueGameBtn').style.display = 'flex';
                                
                                // Update player's winnings
                                const winAmount = message.amount || calculatePotentialWin(gameState.stake);
                                gameState.totalWon += winAmount;
                                updateFinance();
                                
                                showNotification(`·ä†·à∏·äï·çà·ãã·àç! ${winAmount.toLocaleString()} ·â•·à≠ ·â∞·âÄ·à≠·â†·ãã·àç`, false);
                            } else {
                                document.getElementById('winnerStatus').textContent = '·â∞·âÄ·â£·ã≠·äê·âµ ·ä†·àã·åà·äò·àù ‚úó';
                                document.getElementById('continueGameBtn').style.display = 'flex';
                                showNotification('·ã´·à®·åã·åà·å°·âµ ·ä†·à∏·äì·çä·äê·âµ ·â∞·âÄ·â£·ã≠·äê·âµ ·ä†·àã·åà·äò·àù', false);
                            }
                        }
                        break;
                        
                    case 'number_marked':
                        // Server confirmed number marking
                        console.log(`Number ${message.number} marked on server`);
                        break;
                        
                    case 'error':
                        showNotification(message.message, false);
                        break;
                        
                    case 'heartbeat_ack':
                        // Heartbeat acknowledged, connection is alive
                        break;
                        
                    case 'admin_login_success':
                        gameState.isAdmin = true;
                        showNotification('·ä•·äï·ä≥·äï ·ãà·ã∞ ·ä†·àµ·â∞·ã≥·ã∞·à≠ ·çì·äê·àç ·â†·ã∞·àÖ·äì ·àò·å°', false);
                        showAdminPanel();
                        break;
                        
                    case 'admin_login_failed':
                        gameState.isAdmin = false;
                        showNotification('·ã®·ã≠·àà·çç ·âÉ·àç ·ã®·â∞·à≥·à≥·â∞ ·äê·ãç', false);
                        break;
                        
                    case 'info':
                        showNotification(message.message, false);
                        break;
                }
            }

            // [ALL YOUR EXISTING FRONTEND FUNCTIONS REMAIN HERE]
            // Calculate potential win
            function calculatePotentialWin(stake) {
                const validMembers = 90; // Always 90 members
                const potential = (0.8 * validMembers * stake * 0.97);
                return Math.floor(potential);
            }

            // Initialize
            function init() {
                setupBoardSelection();
                setupStakeOptions();
                setupBoardNumbers();
                updatePotentialWin();
                
                // Connect to WebSocket
                connectWebSocket();
                
                document.getElementById('nextBtn').onclick = () => {
                    if (gameState.gameType) showPage(2);
                    else showNotification('·ä•·â£·ä≠·ãé ·ã®·â¶·à≠·ãµ ·ãì·ã≠·äê·âµ ·ã≠·àù·à®·å°', false);
                };
                
                document.getElementById('confirmBtn').onclick = confirmRegistration;
                document.getElementById('playerStake').onchange = updatePotentialWin;
                document.getElementById('paymentAmount').onchange = processPayment;
                document.getElementById('announceBtn').onclick = announceWin;
                
                updateCalledNumbersDisplay();
            }

            // Update the confirmRegistration function
            function confirmRegistration() {
                const name = document.getElementById('playerName').value;
                const phone = document.getElementById('playerPhone').value;
                const stake = document.getElementById('playerStake').value;
                const board = document.getElementById('boardSelect').value;
                
                const incomplete = !name || !phone || !stake || !board || gameState.payment === 0;
                
                if (incomplete) {
                    showNotification('·àò·à®·åÉ·ãé·âΩ ·àô·àâ ·ä†·ã≠·ã∞·àâ·àù·ç¢ ·â†·ãö·àÖ ·àÅ·äî·â≥ ·àò·âÄ·å†·àç ·ã≠·çà·àç·åã·àâ?', true);
                    return;
                }
                
                gameState.playerName = name;
                gameState.playerPhone = phone;
                gameState.stake = parseInt(stake);
                gameState.boardId = board;
                
                // Register with backend
                sendMessage({
                    type: 'register',
                    playerName: name,
                    playerPhone: phone,
                    stake: gameState.stake,
                    boardId: gameState.boardId,
                    gameType: gameState.gameType
                });
                
                showPage(3);
            }

            // Update the announceWin function
            function announceWin() {
                if (!gameState.gameActive) {
                    showNotification('·å®·ãã·â≥ ·ä†·àç·â∞·åÄ·àò·à®·àù', false);
                    return;
                }
                
                const win = calculateWin();
                if (win) {
                    const winAmount = calculatePotentialWin(gameState.stake);
                    
                    sendMessage({
                        type: 'claim_win',
                        playerName: gameState.playerName,
                        playerId: gameState.playerId,
                        pattern: win.pattern,
                        amount: winAmount
                    });
                    
                    // Show local notification
                    document.getElementById('winnerName').textContent = gameState.playerName;
                    document.getElementById('winPattern').textContent = gameState.winConditions[win.pattern] || win.pattern;
                    document.getElementById('displayWinAmount').textContent = `${winAmount.toLocaleString()} ·â•·à≠`;
                    document.getElementById('winnerStatus').textContent = '·â†·àõ·à®·åã·åà·å• ·àã·ã≠...';
                    document.getElementById('continueGameBtn').style.display = 'none';
                    document.getElementById('winnerNotification').style.display = 'block';
                    
                    const audio = document.getElementById('winAudio');
                    audio.currentTime = 0;
                    audio.play().catch(() => {});
                } else {
                    showNotification('·ä†·à∏·äì·çä ·äï·ãµ·çç ·ä†·àç·â∞·å†·äì·âÄ·âÄ·àù·ç¢ ·ä•·â£·ä≠·ãé ·ã≠·âÜ·å•·à©!', false);
                }
            }

            // Function to regenerate board with server numbers
            function regenerateBoardWithServerNumbers() {
                if (!gameState.serverBoardNumbers || !gameState.gameType) return;
                
                const cells = document.querySelectorAll('.board-cell[data-number]');
                if (cells.length === 0) return;
                
                const serverNumbers = gameState.serverBoardNumbers;
                let index = 0;
                
                cells.forEach(cell => {
                    if (cell.dataset.center === 'true') return;
                    
                    if (index < serverNumbers.length) {
                        const num = serverNumbers[index];
                        cell.textContent = num;
                        cell.dataset.number = num;
                        
                        // If number was already marked on server
                        if (gameState.markedNumbers.has(num)) {
                            cell.classList.add('marked');
                        }
                        
                        index++;
                    }
                });
            }

            // [ALL YOUR EXISTING FRONTEND FUNCTIONS CONTINUE...]
            // Setup Board Selection
            function setupBoardSelection() {
                const grid = document.getElementById('boardTypeGrid');
                grid.innerHTML = '';
                
                boardTypes.forEach(type => {
                    const card = document.createElement('div');
                    card.className = 'board-type-card';
                    card.innerHTML = `
                        <div class="board-type-icon">${type.icon}</div>
                        <div class="board-type-title amharic-text">${type.name}</div>
                        <div class="board-type-desc amharic-text">${type.desc}</div>
                    `;
                    card.onclick = () => {
                        document.querySelectorAll('.board-type-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        gameState.gameType = type.id;
                        if (type.id === 'pattern') {
                            const patterns = gameState.winningPatterns.pattern;
                            gameState.currentPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        }
                    };
                    
                    grid.appendChild(card);
                });
            }

            // Setup Stake Options
            function setupStakeOptions() {
                const select = document.getElementById('playerStake');
                const stakes = [25, 50, 100, 200, 500, 1000, 2000, 5000];
                stakes.forEach(stake => {
                    const option = document.createElement('option');
                    option.value = stake;
                    option.textContent = `${stake} ·â•·à≠`;
                    select.appendChild(option);
                });
                select.value = 25;
                gameState.stake = 25;
            }

            // Setup Board Numbers
            function setupBoardNumbers() {
                const select = document.getElementById('boardSelect');
                for (let i = 1; i <= 100; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `·â¶·à≠·ãµ ${i}`;
                    select.appendChild(option);
                }
                select.value = 1;
            }

            // Show Page
            function showPage(pageNum) {
                document.querySelectorAll('.page-container').forEach(page => {
                    page.classList.remove('active');
                });
                document.getElementById(`page${pageNum}`).classList.add('active');
                
                if (pageNum === 3) {
                    generateGameBoard();
                }
                if (pageNum === 4) {
                    updateFinance();
                }
                if (pageNum === 5) {
                    showHelpTab('general');
                }
            }

            // Show Help Tab
            function showHelpTab(tabId) {
                document.querySelectorAll('.help-nav-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.help-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                document.querySelector(`.help-nav-btn[onclick="showHelpTab('${tabId}')"]`).classList.add('active');
                document.getElementById(`help-${tabId}`).classList.add('active');
            }

            // Show Members Modal
            function showMembers() {
                const membersList = document.getElementById('membersList');
                membersList.innerHTML = '';
                
                gameState.members.forEach(member => {
                    const row = document.createElement('tr');
                    row.className = 'member-row';
                    row.innerHTML = `
                        <td>${member.id || 'N/A'}</td>
                        <td class="member-name">${member.name || 'Guest'}</td>
                        <td>${member.phone || 'N/A'}</td>
                        <td class="member-paid">‚úì</td>
                        <td>${member.stake || 25} ·â•·à≠</td>
                        <td>${member.balance || 0} ·â•·à≠</td>
                    `;
                    membersList.appendChild(row);
                });
                
                document.getElementById('membersModal').style.display = 'block';
            }

            // Show Potential Win Modal
            function showPotentialWin() {
                const tbody = document.getElementById('winningTableBody');
                tbody.innerHTML = '';
                
                const stakes = [25, 50, 100, 200, 500, 1000, 2000, 5000];
                stakes.forEach(stake => {
                    const winAmount = calculatePotentialWin(stake);
                    const row = document.createElement('tr');
                    row.className = stake === gameState.stake ? 'current-stake-row' : '';
                    row.innerHTML = `
                        <td class="amharic-text">${stake} ·â•·à≠</td>
                        <td class="win-amount">${winAmount.toLocaleString()} ·â•·à≠</td>
                    `;
                    tbody.appendChild(row);
                });
                
                document.getElementById('potentialWinModal').style.display = 'block';
            }

            // Close Modal
            function closeModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }

            // Update Potential Win Display
            function updatePotentialWin() {
                const stake = parseInt(document.getElementById('playerStake').value) || 25;
                const winAmount = calculatePotentialWin(stake);
                
                document.getElementById('currentWinDisplay').textContent = winAmount.toLocaleString();
                gameState.stake = stake;
            }

            // Show Notification
            function showNotification(message, showContinue) {
                document.getElementById('notificationText').textContent = message;
                document.getElementById('continueBtn').style.display = showContinue ? 'flex' : 'none';
                document.getElementById('notification').style.display = 'block';
            }

            // Hide Notification
            function hideNotification() {
                document.getElementById('notification').style.display = 'none';
            }

            // Continue with incomplete information
            function continueWithIncomplete() {
                hideNotification();
                gameState.playerName = document.getElementById('playerName').value || 'Guest';
                gameState.playerPhone = document.getElementById('playerPhone').value || '0000000000';
                gameState.stake = parseInt(document.getElementById('playerStake').value) || 25;
                gameState.boardId = document.getElementById('boardSelect').value || 1;
                showPage(3);
            }

            // Process Payment
            function processPayment() {
                const amount = parseInt(document.getElementById('paymentAmount').value);
                
                if (!amount || amount < 25) {
                    return;
                }
                
                gameState.payment = amount;
                gameState.paymentAmount = amount;
                
                const select = document.getElementById('paymentAmount');
                select.style.background = '#28a745';
                select.style.color = 'white';
            }

            // Generate Game Board
            function generateGameBoard() {
                const board = document.getElementById('gameBoard');
                const header = document.getElementById('gameHeader');
                const type = boardTypes.find(t => t.id === gameState.gameType);
                
                board.innerHTML = '';
                header.textContent = `${type.name} - ·â¶·à≠·ãµ ${gameState.boardId}`;
                
                if (gameState.gameType === '75ball' || gameState.gameType === '50ball') {
                    generateBingoBoard(type);
                } else if (gameState.gameType === '90ball') {
                    generate90BallBoard(type);
                } else if (gameState.gameType === '30ball') {
                    generate30BallBoard(type);
                } else if (gameState.gameType === 'pattern') {
                    generatePatternBoard(type);
                } else if (gameState.gameType === 'coverall') {
                    generateCoverallBoard(type);
                }
                
                // If server has sent board numbers, regenerate with them
                if (gameState.serverBoardNumbers) {
                    setTimeout(() => {
                        regenerateBoardWithServerNumbers();
                    }, 100);
                }
            }

            // [ALL YOUR EXISTING GAME BOARD GENERATION FUNCTIONS...]
            // Generate BINGO Board (75/50 ball)
            function generateBingoBoard(type) {
                const board = document.getElementById('gameBoard');
                const wrapper = document.createElement('div');
                wrapper.className = 'board-75-wrapper';
                
                // BINGO Labels
                const labels = document.createElement('div');
                labels.className = 'bingo-labels';
                'BINGO'.split('').forEach(letter => {
                    const label = document.createElement('div');
                    label.className = 'bingo-label';
                    label.textContent = letter;
                    labels.appendChild(label);
                });
                wrapper.appendChild(labels);
                
                // Board Grid
                const grid = document.createElement('div');
                grid.className = type.id === '75ball' ? 'board-75' : 'board-50';
                
                // Generate temporary numbers (will be replaced by server numbers if available)
                const columnRanges = type.id === '75ball' ? 
                    [[1,15], [16,30], [31,45], [46,60], [61,75]] :
                    [[1,10], [11,20], [21,30], [31,40], [41,50]];
                
                const columnNumbers = columnRanges.map(range => {
                    let nums = new Set();
                    while (nums.size < 5) {
                        nums.add(Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]);
                    }
                    return Array.from(nums).sort((a, b) => a - b);
                });
                
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        const cell = document.createElement('button');
                        cell.className = 'board-cell';
                        
                        if (row === 2 && col === 2) {
                            cell.textContent = '‚òÖ';
                            cell.classList.add('center-cell');
                            cell.dataset.center = 'true';
                            cell.onclick = () => {
                                if (!cell.classList.contains('marked')) {
                                    cell.classList.add('marked');
                                }
                            };
                        } else {
                            const num = columnNumbers[col][row];
                            cell.textContent = num;
                            cell.dataset.number = num;
                            cell.dataset.row = row;
                            cell.dataset.column = col;
                            cell.onclick = () => toggleMark(cell, num);
                        }
                        
                        grid.appendChild(cell);
                    }
                }
                
                wrapper.appendChild(grid);
                board.appendChild(wrapper);
            }

            // [ALL YOUR EXISTING BOARD GENERATION FUNCTIONS CONTINUE...]
            // Generate 90 Ball Board
            function generate90BallBoard(type) {
                const board = document.getElementById('gameBoard');
                const wrapper = document.createElement('div');
                wrapper.className = 'board-90-wrapper';
                
                // Column labels
                const labels = document.createElement('div');
                labels.className = 'board-90-labels';
                for (let i = 1; i <= 9; i++) {
                    const label = document.createElement('div');
                    label.className = 'board-90-label';
                    label.textContent = `${(i-1)*10+1}-${i*10}`;
                    labels.appendChild(label);
                }
                wrapper.appendChild(labels);
                
                // Board Grid
                const grid = document.createElement('div');
                grid.className = 'board-90';
                
                // Generate temporary numbers
                const ranges = [
                    [1,10], [11,20], [21,30], [31,40], [41,50],
                    [51,60], [61,70], [71,80], [81,90]
                ];
                
                const columnNumbers = ranges.map(range => {
                    const count = Math.floor(Math.random() * 3) + 1;
                    let nums = new Set();
                    while (nums.size < count) {
                        nums.add(Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]);
                    }
                    return Array.from(nums).sort((a, b) => a - b);
                });
                
                const layout = Array(3).fill().map(() => Array(9).fill(null));
                
                columnNumbers.forEach((nums, col) => {
                    const positions = [0,1,2].sort(() => Math.random() - 0.5).slice(0, nums.length);
                    positions.forEach((row, idx) => {
                        layout[row][col] = nums[idx];
                    });
                });
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('button');
                        cell.className = 'board-cell';
                        const num = layout[row][col];
                        
                        if (num) {
                            cell.textContent = num;
                            cell.dataset.number = num;
                            cell.dataset.row = row;
                            cell.dataset.column = col;
                            
                            if (row === 1 && col === 4) {
                                cell.classList.add('center-cell');
                                cell.dataset.center = 'true';
                            }
                            
                            cell.onclick = () => toggleMark(cell, num);
                        } else {
                            cell.classList.add('blank-cell');
                            cell.textContent = '‚úó';
                        }
                        
                        grid.appendChild(cell);
                    }
                }
                
                wrapper.appendChild(grid);
                board.appendChild(wrapper);
            }

            // Generate 30 Ball Board
            function generate30BallBoard(type) {
                const board = document.getElementById('gameBoard');
                const wrapper = document.createElement('div');
                wrapper.className = 'board-30-wrapper';
                
                // Column labels
                const labels = document.createElement('div');
                labels.className = 'board-30-labels';
                for (let i = 1; i <= 3; i++) {
                    const label = document.createElement('div');
                    label.className = 'board-30-label';
                    label.textContent = `${(i-1)*10+1}-${i*10}`;
                    labels.appendChild(label);
                }
                wrapper.appendChild(labels);
                
                // Board Grid
                const grid = document.createElement('div');
                grid.className = 'board-30';
                
                // Generate temporary numbers
                let nums = new Set();
                while (nums.size < 9) {
                    nums.add(Math.floor(Math.random() * 30) + 1);
                }
                const numbers = Array.from(nums).sort((a, b) => a - b);
                
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('button');
                    cell.className = 'board-cell';
                    cell.textContent = numbers[i];
                    cell.dataset.number = numbers[i];
                    cell.dataset.index = i;
                    
                    if (i === 4) {
                        cell.classList.add('center-cell');
                        cell.dataset.center = 'true';
                    }
                    
                    cell.onclick = () => toggleMark(cell, numbers[i]);
                    
                    grid.appendChild(cell);
                }
                
                wrapper.appendChild(grid);
                board.appendChild(wrapper);
            }

            // Generate Pattern Board
            function generatePatternBoard(type) {
                const board = document.getElementById('gameBoard');
                const wrapper = document.createElement('div');
                wrapper.className = 'board-pattern-wrapper';
                
                // BINGO Labels
                const labels = document.createElement('div');
                labels.className = 'board-pattern-labels';
                'BINGO'.split('').forEach(letter => {
                    const label = document.createElement('div');
                    label.className = 'board-pattern-label';
                    label.textContent = letter;
                    labels.appendChild(label);
                });
                wrapper.appendChild(labels);
                
                // Board Grid
                const grid = document.createElement('div');
                grid.className = 'board-pattern';
                
                // Generate temporary numbers
                const columnRanges = [[1,15], [16,30], [31,45], [46,60], [61,75]];
                const columnNumbers = columnRanges.map(range => {
                    let nums = new Set();
                    while (nums.size < 5) {
                        nums.add(Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]);
                    }
                    return Array.from(nums).sort((a, b) => a - b);
                });
                
                // Define pattern cells
                const patternCells = getPatternCells(gameState.currentPattern);
                
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        const cell = document.createElement('button');
                        cell.className = 'board-cell';
                        
                        if (row === 2 && col === 2) {
                            cell.textContent = '‚òÖ';
                            cell.classList.add('center-cell');
                            cell.dataset.center = 'true';
                            cell.onclick = () => {
                                if (!cell.classList.contains('marked')) {
                                    cell.classList.add('marked');
                                }
                            };
                        } else {
                            const num = columnNumbers[col][row];
                            cell.textContent = num;
                            cell.dataset.number = num;
                            cell.dataset.row = row;
                            cell.dataset.column = col;
                            
                            if (patternCells.includes(`${row}-${col}`)) {
                                cell.classList.add('pattern-cell');
                            }
                            
                            cell.onclick = () => toggleMark(cell, num);
                        }
                        
                        grid.appendChild(cell);
                    }
                }
                
                wrapper.appendChild(grid);
                board.appendChild(wrapper);
            }

            // Generate Coverall Board
            function generateCoverallBoard(type) {
                const board = document.getElementById('gameBoard');
                const wrapper = document.createElement('div');
                wrapper.className = 'board-coverall-wrapper';
                
                // Column labels
                const labels = document.createElement('div');
                labels.className = 'board-coverall-labels';
                for (let i = 1; i <= 9; i++) {
                    const label = document.createElement('div');
                    label.className = 'board-coverall-label';
                    label.textContent = `${(i-1)*10+1}-${i*10}`;
                    labels.appendChild(label);
                }
                wrapper.appendChild(labels);
                
                // Board Grid
                const grid = document.createElement('div');
                grid.className = 'board-coverall';
                
                // Generate temporary numbers
                let allNumbers = Array.from({length: 90}, (_, i) => i + 1);
                allNumbers = shuffleArray(allNumbers).slice(0, 45);
                
                for (let i = 0; i < 45; i++) {
                    const row = Math.floor(i / 9);
                    const col = i % 9;
                    const cell = document.createElement('button');
                    cell.className = 'board-cell';
                    cell.textContent = allNumbers[i];
                    cell.dataset.number = allNumbers[i];
                    cell.dataset.index = i;
                    
                    if (row === 2 && col === 4) {
                        cell.classList.add('center-cell');
                        cell.dataset.center = 'true';
                    }
                    
                    cell.onclick = () => toggleMark(cell, allNumbers[i]);
                    
                    grid.appendChild(cell);
                }
                
                wrapper.appendChild(grid);
                board.appendChild(wrapper);
            }

            // Get pattern cells
            function getPatternCells(pattern) {
                const patterns = {
                    'x-pattern': ['0-0', '0-4', '1-1', '1-3', '2-2', '3-1', '3-3', '4-0', '4-4'],
                    'frame': ['0-0', '0-1', '0-2', '0-3', '0-4', '4-0', '4-1', '4-2', '4-3', '4-4', '1-0', '2-0', '3-0', '1-4', '2-4', '3-4'],
                    'postage-stamp': ['0-0', '0-1', '1-0', '1-1', '3-3', '3-4', '4-3', '4-4'],
                    'small-diamond': ['1-2', '2-1', '2-2', '2-3', '3-2']
                };
                return patterns[pattern] || patterns['x-pattern'];
            }

            // Shuffle array
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Toggle Mark
            function toggleMark(cell, number) {
                if (!gameState.gameActive) {
                    showNotification('·å®·ãã·â≥ ·ä†·àç·â∞·åÄ·àò·à®·àù', false);
                    return;
                }
                
                if (!gameState.calledNumbers.includes(number)) {
                    showNotification('·ã≠·àÖ ·âÅ·å•·à≠ ·ä†·àç·â∞·å†·à´·àù', false);
                    return;
                }
                
                if (cell.classList.contains('marked')) {
                    cell.classList.remove('marked');
                    gameState.markedNumbers.delete(number);
                } else {
                    cell.classList.add('marked');
                    gameState.markedNumbers.add(number);
                    
                    // Send to server
                    sendMessage({
                        type: 'mark_number',
                        playerId: gameState.playerId,
                        number: number
                    });
                }
            }

            // Update Connection Status UI
            function updateConnectionStatus(status, text) {
                const statusDiv = document.getElementById('connectionStatus');
                const statusIcon = document.getElementById('statusIcon');
                const statusText = document.getElementById('statusText');
                
                statusDiv.className = `connection-status status-${status}`;
                statusText.textContent = text;
                
                switch(status) {
                    case 'connected':
                        statusIcon.textContent = 'üü¢';
                        break;
                    case 'disconnected':
                        statusIcon.textContent = 'üî¥';
                        break;
                    case 'connecting':
                        statusIcon.textContent = 'üü°';
                        break;
                }
            }

            // Update Game State
            function updateGameState(state) {
                if (state.calledNumbers) {
                    gameState.calledNumbers = state.calledNumbers;
                    updateCalledNumbersDisplay();
                }
                
                if (state.gameActive !== undefined) {
                    gameState.gameActive = state.gameActive;
                    document.getElementById('announceBtn').disabled = !state.gameActive;
                }
                
                if (state.players) {
                    gameState.members = state.players;
                    updatePlayersList(state.players);
                }
                
                if (gameState.isAdmin) {
                    document.getElementById('activePlayers').textContent = state.players ? state.players.length : 0;
                    if (state.calledNumbers) {
                        document.getElementById('adminCalledCount').textContent = state.calledNumbers.length;
                    }
                }
            }

            // Update Players List
            function updatePlayersList(players) {
                gameState.members = players;
                document.getElementById('membersCount').textContent = players.length;
            }

            // Handle Number Called
            function handleNumberCalled(number, display) {
                gameState.calledNumbers.push(number);
                
                // Update UI
                const bar = document.getElementById('calledNumbersBar');
                const span = document.createElement('span');
                span.className = 'called-number amharic-text';
                span.textContent = display || number;
                bar.appendChild(span);
                
                // Keep only last 8 numbers
                while (bar.children.length > 8) {
                    bar.removeChild(bar.firstChild);
                }
                
                // Scroll to end
                bar.scrollLeft = bar.scrollWidth;
                
                // Play sound
                const audio = document.getElementById('callAudio');
                audio.currentTime = 0;
                audio.play().catch(() => {});
                
                // Mark number on board if exists
                markNumberOnBoard(number);
            }

            // Mark Number on Board
            function markNumberOnBoard(number) {
                const cells = document.querySelectorAll('.board-cell[data-number]');
                cells.forEach(cell => {
                    if (parseInt(cell.dataset.number) === number) {
                        if (!cell.classList.contains('marked')) {
                            cell.classList.add('marked');
                            gameState.markedNumbers.add(number);
                        }
                    }
                });
            }

            // Update Called Numbers Display
            function updateCalledNumbersDisplay() {
                const bar = document.getElementById('calledNumbersBar');
                bar.innerHTML = '';
                
                gameState.calledNumbers.forEach(num => {
                    const span = document.createElement('span');
                    span.className = 'called-number amharic-text';
                    span.textContent = num;
                    bar.appendChild(span);
                });
                
                if (gameState.calledNumbers.length === 0) {
                    bar.innerHTML = '<span style="color: #888; font-style: italic;" class="amharic-text">·âÅ·å•·àÆ·âΩ ·ã≠·å†·à´·àâ...</span>';
                }
            }

            // Calculate Win
            function calculateWin() {
                const type = gameState.gameType;
                const patterns = gameState.winningPatterns[type];
                
                for (const pattern of patterns) {
                    if (checkPattern(pattern)) {
                        return { pattern: pattern };
                    }
                }
                
                return null;
            }

            // Check Specific Pattern
            function checkPattern(pattern) {
                const cells = document.querySelectorAll('.board-cell:not(.blank-cell)');
                const markedCells = Array.from(cells).filter(cell => 
                    cell.classList.contains('marked') || 
                    (cell.classList.contains('center-cell') && 
                     (gameState.gameType === '75ball' || gameState.gameType === '50ball' || gameState.gameType === 'pattern'))
                );
                
                const markedPositions = new Set();
                markedCells.forEach(cell => {
                    if (cell.dataset.row !== undefined && cell.dataset.column !== undefined) {
                        markedPositions.add(`${cell.dataset.row}-${cell.dataset.column}`);
                    } else if (cell.dataset.index !== undefined) {
                        markedPositions.add(`i${cell.dataset.index}`);
                    }
                });
                
                switch(gameState.gameType) {
                    case '75ball':
                    case '50ball':
                        return check75BallPattern(pattern, markedPositions);
                    case '90ball':
                        return check90BallPattern(pattern, markedPositions);
                    case '30ball':
                        return check30BallPattern(pattern, markedPositions);
                    case 'pattern':
                        return checkPatternBingo(pattern, markedPositions);
                    case 'coverall':
                        return checkCoverallPattern(pattern, markedPositions);
                    default:
                        return false;
                }
            }

            // Check 75-Ball Patterns
            function check75BallPattern(pattern, markedPositions) {
                switch(pattern) {
                    case 'row':
                        for (let row = 0; row < 5; row++) {
                            let complete = true;
                            for (let col = 0; col < 5; col++) {
                                const pos = `${row}-${col}`;
                                if (row === 2 && col === 2) continue;
                                if (!markedPositions.has(pos)) {
                                    complete = false;
                                    break;
                                }
                            }
                            if (complete) return true;
                        }
                        return false;
                        
                    case 'column':
                        for (let col = 0; col < 5; col++) {
                            let complete = true;
                            for (let row = 0; row < 5; row++) {
                                const pos = `${row}-${col}`;
                                if (row === 2 && col === 2) continue;
                                if (!markedPositions.has(pos)) {
                                    complete = false;
                                    break;
                                }
                            }
                            if (complete) return true;
                        }
                        return false;
                        
                    case 'diagonal':
                        let diag1Complete = true;
                        for (let i = 0; i < 5; i++) {
                            const pos = `${i}-${i}`;
                            if (i === 2) continue;
                            if (!markedPositions.has(pos)) {
                                diag1Complete = false;
                                break;
                            }
                        }
                        if (diag1Complete) return true;
                        
                        let diag2Complete = true;
                        for (let i = 0; i < 5; i++) {
                            const pos = `${i}-${4-i}`;
                            if (i === 2) continue;
                            if (!markedPositions.has(pos)) {
                                diag2Complete = false;
                                break;
                            }
                        }
                        return diag2Complete;
                        
                    case 'four-corners':
                        const corners = ['0-0', '0-4', '4-0', '4-4'];
                        return corners.every(pos => markedPositions.has(pos));
                        
                    case 'full-house':
                        for (let row = 0; row < 5; row++) {
                            for (let col = 0; col < 5; col++) {
                                if (row === 2 && col === 2) continue;
                                const pos = `${row}-${col}`;
                                if (!markedPositions.has(pos)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                        
                    default:
                        return false;
                }
            }

            // Check 90-Ball Patterns
            function check90BallPattern(pattern, markedPositions) {
                const rowCounts = [0, 0, 0];
                const totalCells = 15;
                
                const markedCells = Array.from(document.querySelectorAll('.board-cell:not(.blank-cell)')).filter(cell => 
                    cell.classList.contains('marked')
                );
                
                markedCells.forEach(cell => {
                    if (cell.dataset.row !== undefined) {
                        const row = parseInt(cell.dataset.row);
                        if (row >= 0 && row < 3) {
                            rowCounts[row]++;
                        }
                    }
                });
                
                switch(pattern) {
                    case 'one-line':
                        return rowCounts.some(count => count >= 5);
                        
                    case 'two-lines':
                        const rowsWithAllNumbers = rowCounts.filter(count => count >= 5);
                        return rowsWithAllNumbers.length >= 2;
                        
                    case 'full-house':
                        return markedCells.length >= totalCells;
                        
                    default:
                        return false;
                }
            }

            // Check 30-Ball Pattern
            function check30BallPattern(pattern, markedPositions) {
                if (pattern === 'full-house') {
                    return markedPositions.size >= 9;
                }
                return false;
            }

            // Check Pattern Bingo
            function checkPatternBingo(pattern, markedPositions) {
                const patternCells = getPatternCells(pattern);
                return patternCells.every(pos => markedPositions.has(pos));
            }

            // Check Coverall Pattern
            function checkCoverallPattern(pattern, markedPositions) {
                if (pattern === 'full-board') {
                    return markedPositions.size >= 45;
                }
                return false;
            }

            // Continue Game
            function continueGame() {
                document.getElementById('winnerNotification').style.display = 'none';
            }

            // Update Finance
            function updateFinance() {
                const balance = gameState.payment + gameState.totalWon - gameState.totalWithdrawn;
                const withdraw = Math.floor(balance * 0.97);
                
                document.getElementById('totalPayment').value = `${gameState.payment} ·â•·à≠`;
                document.getElementById('totalWon').value = `${gameState.totalWon.toLocaleString()} ·â•·à≠`;
                document.getElementById('currentBalance').value = `${balance.toLocaleString()} ·â•·à≠`;
                document.getElementById('withdrawAmount').value = `${withdraw.toLocaleString()} ·â•·à≠`;
            }

            // Process Withdrawal
            function processWithdrawal() {
                const account = document.getElementById('withdrawAccount').value;
                const amount = parseInt(document.getElementById('withdrawAmount').value.replace(/,/g, ''));
                
                if (!account) {
                    showNotification('·ã®·ä†·ä´·ãç·äï·âµ ·âÅ·å•·à≠ ·ã´·àµ·åà·â°', false);
                    return;
                }
                
                if (amount < 25) {
                    showNotification('·ãù·âÖ·â∞·äõ ·àò·å†·äï 25 ·â•·à≠', false);
                    return;
                }
                
                const balance = gameState.payment + gameState.totalWon - gameState.totalWithdrawn;
                if (amount > balance) {
                    showNotification('·â†·âÇ ·àö·ãõ·äï ·ã®·àà·àù', false);
                    return;
                }
                
                gameState.totalWithdrawn += amount;
                updateFinance();
                showNotification(`${amount.toLocaleString()} ·â•·à≠ ·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·â∞·ãà·åç·ã∑·àç!`, false);
            }

            // Admin Functions
            function showAdminPanel() {
                document.getElementById('adminPanel').style.display = 'block';
                // Request game state
                sendMessage({ type: 'get_state' });
            }

            function toggleAdminPanel() {
                const panel = document.getElementById('adminPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }

            function sendAdminCommand(command) {
                if (!gameState.isAdmin) {
                    showNotification('·ã®·ä†·àµ·â∞·ã≥·ã∞·à≠ ·àò·â•·âµ ·ã®·àà·ãé·âµ·àù', false);
                    return;
                }
                
                sendMessage({ type: 'admin_command', command: command });
            }

            // Initialize on load
            window.addEventListener('DOMContentLoaded', init);
            
            // Mobile compatibility
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('gesturestart', (e) => e.preventDefault());
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    window.scrollTo(0, 0);
                    if (gameState.gameType) {
                        generateGameBoard();
                    }
                }, 100);
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (e) => {
                const membersModal = document.getElementById('membersModal');
                const potentialWinModal = document.getElementById('potentialWinModal');
                
                if (e.target === membersModal) {
                    membersModal.style.display = 'none';
                }
                if (e.target === potentialWinModal) {
                    potentialWinModal.style.display = 'none';
                }
            });
            
            // Ensure boards fit on resize
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (gameState.gameType) {
                        generateGameBoard();
                    }
                }, 250);
            });
        }
    </script>
</body>
</html>
